//@version=6
strategy(title = 'SAIYAN OCC Strategy with MTFTI, Supply/Demand & Candlestick Patterns', overlay = true, pyramiding = 0, default_qty_type = strategy.percent_of_equity, default_qty_value = 10, calc_on_every_tick = false)

//===== INPUTS =====
// SAIYAN OCC Strategy Inputs
res = input.timeframe(title = 'TIMEFRAME', defval = '15', group = 'NON REPAINT')
useRes = input(defval = true, title = 'Use Alternate Signals', group = 'NON REPAINT')
intRes = input(defval = 8, title = 'Multiplier for Alernate Signals', group = 'NON REPAINT')
stratRes = timeframe.ismonthly ? str.tostring(timeframe.multiplier * intRes, '###M') : timeframe.isweekly ? str.tostring(timeframe.multiplier * intRes, '###W') : timeframe.isdaily ? str.tostring(timeframe.multiplier * intRes, '###D') : timeframe.isintraday ? str.tostring(timeframe.multiplier * intRes, '####') : '60'
basisType = input.string(defval = 'ALMA', title = 'MA Type: ', options = ['TEMA', 'HullMA', 'ALMA'], group = 'NON REPAINT')
basisLen = input.int(defval = 2, title = 'MA Period', minval = 1, group = 'NON REPAINT')
offsetSigma = input.int(defval = 5, title = 'Offset for LSMA / Sigma for ALMA', minval = 0, group = 'NON REPAINT')
offsetALMA = input.float(defval = 0.85, title = 'Offset for ALMA', minval = 0, step = 0.01, group = 'NON REPAINT')
scolor = input(true, title = 'Show coloured Bars to indicate Trend?', group = 'NON REPAINT')
delayOffset = input.int(defval = 0, title = 'Delay Open/Close MA (Forces Non-Repainting)', minval = 0, step = 1, group = 'NON REPAINT')
tradeType = input.string('BOTH', title = 'What trades should be taken : ', options = ['LONG', 'SHORT', 'BOTH', 'NONE'], group = 'NON REPAINT')

// Supply Demand Indicator Settings
h = input(false, title = 'Signals for Heikin Ashi Candles', group = 'Supply/Demand')
swing_length = input.int(10, title = 'Swing High/Low Length', group = 'Supply/Demand Settings', minval = 1, maxval = 50)
history_of_demand_to_keep = input.int(20, title = 'History To Keep', group = 'Supply/Demand Settings', minval = 5, maxval = 50)
box_width = input.float(1.5, title = 'Supply/Demand Box Width', group = 'Supply/Demand Settings', minval = 1, maxval = 10, step = 0.5)

// Supply Demand Visual Settings
show_zigzag = input.bool(true, title = 'Show Zig Zag', group = 'Supply/Demand Visual')
show_price_action_labels = input.bool(true, title = 'Show Price Action Labels', group = 'Supply/Demand Visual')
supply_color = input.color(color.new(color.black, 75), title = 'Supply', group = 'Supply/Demand Visual')
supply_outline_color = input.color(color.new(color.black, 75), title = 'Outline', group = 'Supply/Demand Visual')
demand_color = input.color(color.new(color.black, 75), title = 'Demand', group = 'Supply/Demand Visual')
demand_outline_color = input.color(color.new(color.black, 75), title = 'Outline', group = 'Supply/Demand Visual')
bos_label_color = input.color(color.black, title = 'BOS Label', group = 'Supply/Demand Visual')
poi_label_color = input.color(color.black, title = 'POI Label', group = 'Supply/Demand Visual')
swing_type_color = input.color(color.black, title = 'Price Action Label', group = 'Supply/Demand Visual')
zigzag_color = input.color(color.new(#000000, 0), title = 'Zig Zag', group = 'Supply/Demand Visual')

// MTFTI Settings
maType = input.string(title = 'MTFTI MA Type', defval = 'EMA', options = ['SMA', 'EMA', 'WMA', 'AMA'], group = 'MTFTI')
tablePosition = input.string(title = 'MTFTI Table Position', defval = 'bottom_right', options = ['top_left', 'top_right', 'middle_left', 'middle_right', 'bottom_left', 'bottom_right'], group = 'MTFTI')

// MTFTI Timeframe Selection
showTf1 = input(true, title = 'Show 1min', group = 'MTFTI Timeframes')
showTf2 = input(true, title = 'Show 2min', group = 'MTFTI Timeframes')
showTf3 = input(true, title = 'Show 3min', group = 'MTFTI Timeframes')
showTf4 = input(true, title = 'Show 5min', group = 'MTFTI Timeframes')
showTf5 = input(true, title = 'Show 10min', group = 'MTFTI Timeframes')
showTf6 = input(true, title = 'Show 15min', group = 'MTFTI Timeframes')
showTf7 = input(true, title = 'Show 30min', group = 'MTFTI Timeframes')
showTf8 = input(true, title = 'Show 1H', group = 'MTFTI Timeframes')
showTf9 = input(true, title = 'Show 2H', group = 'MTFTI Timeframes')
showTf10 = input(true, title = 'Show 4H', group = 'MTFTI Timeframes')
showTf11 = input(true, title = 'Show 6H', group = 'MTFTI Timeframes')
showTf12 = input(true, title = 'Show 12H', group = 'MTFTI Timeframes')
showTf13 = input(true, title = 'Show 1 Day', group = 'MTFTI Timeframes')
showTf14 = input(true, title = 'Show 1 week', group = 'MTFTI Timeframes')
showTf15 = input(true, title = 'Show AVG', group = 'MTFTI Timeframes')

// MTFTI EMA Settings
shortTerm = input(7, title = 'Short Term EMA Length', group = 'MTFTI EMA')
longTerm = input(21, title = 'Long Term EMA Length', group = 'MTFTI EMA')
longLongTerm = input(50, title = 'Long Long Term EMA Length', group = 'MTFTI EMA')
longLongLongTerm = input(200, title = 'Long Long Long Term EMA Length', group = 'MTFTI EMA')
showShortTerm = input(true, title = 'Show Short Term EMA', group = 'MTFTI EMA')
showLongTerm = input(true, title = 'Show Long Term EMA', group = 'MTFTI EMA')
showLongLongTerm = input(false, title = 'Show Long Long Term EMA', group = 'MTFTI EMA')
showLongLongLongTerm = input(false, title = 'Show Long Long Long Term EMA', group = 'MTFTI EMA')

// Channel Balance
channelBal = input.bool(false, 'Channel Balance', group = 'CHART')

// Strategy Settings
slPoints = input.int(defval = 0, title = 'Initial Stop Loss Points (zero to disable)', minval = 0, group = 'Strategy')
tpPoints = input.int(defval = 0, title = 'Initial Target Profit Points (zero for disable)', minval = 0, group = 'Strategy')
ebar = input.int(defval = 0, title = 'Number of Bars for Back Testing', minval = 0, group = 'Strategy')
dummy = input(false, title = '- SET to ZERO for Daily or Longer Timeframes', group = 'Strategy')

// Alert Messages
i_alert_txt_entry_long = input.text_area(defval = 'Entry Long', title = 'Long Entry Message', group = 'Alerts')
i_alert_txt_entry_short = input.text_area(defval = 'Entry Short', title = 'Short Entry Message', group = 'Alerts')

// MTFTI Color Settings
colorStrongDown = input.color(color.rgb(172, 1, 1), title = 'colorStrongDown', group = 'MTFTI Color')
colorDown = input.color(color.red, title = 'colorDown', group = 'MTFTI Color')
colorStrongUp = input.color(color.rgb(1, 128, 5), title = 'colorStrongUp', group = 'MTFTI Color')
colorUp = input.color(color.green, title = 'colorUp', group = 'MTFTI Color')

// Candlestick Pattern Settings
use_candlestick_patterns = input.bool(true, title = "Use Candlestick Patterns", group = "Candlestick Patterns")
candlestick_trendRule = input.string("SMA50", "Detect Trend Based On", options=["SMA50", "SMA50, SMA200", "No detection"], group = "Candlestick Patterns")
CandleType = input.string("Both", title = "Pattern Type", options=["Bullish", "Bearish", "Both"], group = "Candlestick Patterns")

// Label Color Settings
label_color_bullish = input.color(color.blue, "Label Color Bullish", group = "Candlestick Patterns")
label_color_bearish = input.color(color.red, "Label Color Bearish", group = "Candlestick Patterns")
label_color_neutral = input.color(color.gray, "Label Color Neutral", group = "Candlestick Patterns")

// Candlestick Pattern Selection
AbandonedBabyInput = input(title = "Abandoned Baby", defval=true, group = "Candlestick Pattern Selection") 
DarkCloudCoverInput = input(title = "Dark Cloud Cover", defval=false, group = "Candlestick Pattern Selection") 
DojiInput = input(title = "Doji", defval=true, group = "Candlestick Pattern Selection") 
DojiStarInput = input(title = "Doji Star", defval=false, group = "Candlestick Pattern Selection") 
DownsideTasukiGapInput = input(title = "Downside Tasuki Gap", defval=false, group = "Candlestick Pattern Selection") 
DragonflyDojiInput = input(title = "Dragonfly Doji", defval=true, group = "Candlestick Pattern Selection") 
EngulfingInput = input(title = "Engulfing", defval=true, group = "Candlestick Pattern Selection") 
EveningDojiStarInput = input(title = "Evening Doji Star", defval=false, group = "Candlestick Pattern Selection") 
EveningStarInput = input(title = "Evening Star", defval=false, group = "Candlestick Pattern Selection") 
FallingThreeMethodsInput = input(title = "Falling Three Methods", defval=false, group = "Candlestick Pattern Selection") 
FallingWindowInput = input(title = "Falling Window", defval=false, group = "Candlestick Pattern Selection") 
GravestoneDojiInput = input(title = "Gravestone Doji", defval=false, group = "Candlestick Pattern Selection") 
HammerInput = input(title = "Hammer", defval=true, group = "Candlestick Pattern Selection") 
HangingManInput = input(title = "Hanging Man", defval=false, group = "Candlestick Pattern Selection") 
HaramiCrossInput = input(title = "Harami Cross", defval=false, group = "Candlestick Pattern Selection") 
HaramiInput = input(title = "Harami", defval=false, group = "Candlestick Pattern Selection") 
InvertedHammerInput = input(title = "Inverted Hammer", defval=false, group = "Candlestick Pattern Selection") 
KickingInput = input(title = "Kicking", defval=false, group = "Candlestick Pattern Selection") 
LongLowerShadowInput = input(title = "Long Lower Shadow", defval=false, group = "Candlestick Pattern Selection") 
LongUpperShadowInput = input(title = "Long Upper Shadow", defval=false, group = "Candlestick Pattern Selection") 
MarubozuBlackInput = input(title = "Marubozu Black", defval=false, group = "Candlestick Pattern Selection") 
MarubozuWhiteInput = input(title = "Marubozu White", defval=false, group = "Candlestick Pattern Selection") 
MorningDojiStarInput = input(title = "Morning Doji Star", defval=false, group = "Candlestick Pattern Selection") 
MorningStarInput = input(title = "Morning Star", defval=false, group = "Candlestick Pattern Selection") 
OnNeckInput = input(title = "On Neck", defval=false, group = "Candlestick Pattern Selection") 
PiercingInput = input(title = "Piercing", defval=false, group = "Candlestick Pattern Selection") 
RisingThreeMethodsInput = input(title = "Rising Three Methods", defval=false, group = "Candlestick Pattern Selection") 
RisingWindowInput = input(title = "Rising Window", defval=false, group = "Candlestick Pattern Selection") 
ShootingStarInput = input(title = "Shooting Star", defval=false, group = "Candlestick Pattern Selection") 
SpinningTopBlackInput = input(title = "Spinning Top Black", defval=false, group = "Candlestick Pattern Selection") 
SpinningTopWhiteInput = input(title = "Spinning Top White", defval=false, group = "Candlestick Pattern Selection") 
ThreeBlackCrowsInput = input(title = "Three Black Crows", defval=false, group = "Candlestick Pattern Selection") 
ThreeWhiteSoldiersInput = input(title = "Three White Soldiers", defval=false, group = "Candlestick Pattern Selection") 
TriStarInput = input(title = "Tri-Star", defval=false, group = "Candlestick Pattern Selection") 
TweezerBottomInput = input(title = "Tweezer Bottom", defval=false, group = "Candlestick Pattern Selection") 
TweezerTopInput = input(title = "Tweezer Top", defval=false, group = "Candlestick Pattern Selection") 
UpsideTasukiGapInput = input(title = "Upside Tasuki Gap", defval=false, group = "Candlestick Pattern Selection") 

//===== /INPUTS =====

//===== FUNCTIONS =====
// SAIYAN OCC Functions
variant(type, src, len, offSig, offALMA) =>
    v1 = ta.sma(src, len) // Simple
    v2 = ta.ema(src, len) // Exponential
    v3 = 2 * v2 - ta.ema(v2, len) // Double Exponential
    v4 = 3 * (v2 - ta.ema(v2, len)) + ta.ema(ta.ema(v2, len), len) // Triple Exponential
    v5 = ta.wma(src, len) // Weighted
    v6 = ta.vwma(src, len) // Volume Weighted
    v7 = 0.0
    sma_1 = ta.sma(src, len) // Smoothed
    v7 := na(v7[1]) ? sma_1 : (v7[1] * (len - 1) + src) / len
    v8 = ta.wma(2 * ta.wma(src, len / 2) - ta.wma(src, len), math.round(math.sqrt(len))) // Hull
    v9 = ta.linreg(src, len, offSig) // Least Squares
    v10 = ta.alma(src, len, offALMA, offSig) // Arnaud Legoux
    v11 = ta.sma(v1, len) // Triangular (extreme smooth)
    // SuperSmoother filter
    //   2013  John F. Ehlers
    a1 = math.exp(-1.414 * 3.14159 / len)
    b1 = 2 * a1 * math.cos(1.414 * 3.14159 / len)
    c2 = b1
    c3 = -a1 * a1
    c1 = 1 - c2 - c3
    v12 = 0.0
    v12 := c1 * (src + nz(src[1])) / 2 + c2 * nz(v12[1]) + c3 * nz(v12[2])
    type == 'EMA' ? v2 : type == 'DEMA' ? v3 : type == 'TEMA' ? v4 : type == 'WMA' ? v5 : type == 'VWMA' ? v6 : type == 'SMMA' ? v7 : type == 'HullMA' ? v8 : type == 'LSMA' ? v9 : type == 'ALMA' ? v10 : type == 'TMA' ? v11 : type == 'SSMA' ? v12 : v1

// Security wrapper for repeat calls
reso(exp, use, res) =>
    security_1 = request.security(syminfo.tickerid, res, exp, gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)
    use ? security_1 : exp

// Supply/Demand Functions
f_array_add_pop(array, new_value_to_add) =>
    array.unshift(array, new_value_to_add)
    array.pop(array)

f_sh_sl_labels(array, swing_type) =>
    var string label_text = na
    if swing_type == 1
        if array.get(array, 0) >= array.get(array, 1)
            label_text := 'HH'
            label_text
        else
            label_text := 'LH'
            label_text
        label.new(bar_index - swing_length, array.get(array, 0), text = label_text, style = label.style_label_down, textcolor = swing_type_color, color = color.new(swing_type_color, 100), size = size.tiny)

    else if swing_type == -1
        if array.get(array, 0) >= array.get(array, 1)
            label_text := 'HL'
            label_text
        else
            label_text := 'LL'
            label_text
        label.new(bar_index - swing_length, array.get(array, 0), text = label_text, style = label.style_label_up, textcolor = swing_type_color, color = color.new(swing_type_color, 100), size = size.tiny)

f_check_overlapping(new_poi, box_array, atr) =>
    atr_threshold = atr * 2
    okay_to_draw = true

    for i = 0 to array.size(box_array) - 1 by 1
        top = box.get_top(array.get(box_array, i))
        bottom = box.get_bottom(array.get(box_array, i))
        poi = (top + bottom) / 2

        upper_boundary = poi + atr_threshold
        lower_boundary = poi - atr_threshold

        if new_poi >= lower_boundary and new_poi <= upper_boundary
            okay_to_draw := false
            break
        else
            okay_to_draw := true
            okay_to_draw
    okay_to_draw

f_supply_demand(value_array, bn_array, box_array, label_array, box_type, atr) =>
    atr_buffer = atr * (box_width / 10)
    box_left = array.get(bn_array, 0)
    box_right = bar_index

    var float box_top = 0.00
    var float box_bottom = 0.00
    var float poi = 0.00

    if box_type == 1
        box_top := array.get(value_array, 0)
        box_bottom := box_top - atr_buffer
        poi := (box_top + box_bottom) / 2
        poi
    else if box_type == -1
        box_bottom := array.get(value_array, 0)
        box_top := box_bottom + atr_buffer
        poi := (box_top + box_bottom) / 2
        poi

    okay_to_draw = f_check_overlapping(poi, box_array, atr)

    if box_type == 1 and okay_to_draw
        box.delete(array.get(box_array, array.size(box_array) - 1))
        f_array_add_pop(box_array, box.new(left = box_left, top = box_top, right = box_right, bottom = box_bottom, border_color = supply_outline_color, bgcolor = supply_color, extend = extend.right, text = 'SUPPLY', text_halign = text.align_center, text_valign = text.align_center, text_color = poi_label_color, text_size = size.small, xloc = xloc.bar_index))

        box.delete(array.get(label_array, array.size(label_array) - 1))
        f_array_add_pop(label_array, box.new(left = box_left, top = poi, right = box_right, bottom = poi, border_color = color.new(poi_label_color, 90), bgcolor = color.new(poi_label_color, 90), extend = extend.right, text = 'POI', text_halign = text.align_left, text_valign = text.align_center, text_color = poi_label_color, text_size = size.small, xloc = xloc.bar_index))

    else if box_type == -1 and okay_to_draw
        box.delete(array.get(box_array, array.size(box_array) - 1))
        f_array_add_pop(box_array, box.new(left = box_left, top = box_top, right = box_right, bottom = box_bottom, border_color = demand_outline_color, bgcolor = demand_color, extend = extend.right, text = 'DEMAND', text_halign = text.align_center, text_valign = text.align_center, text_color = poi_label_color, text_size = size.small, xloc = xloc.bar_index))

        box.delete(array.get(label_array, array.size(label_array) - 1))
        f_array_add_pop(label_array, box.new(left = box_left, top = poi, right = box_right, bottom = poi, border_color = color.new(poi_label_color, 90), bgcolor = color.new(poi_label_color, 90), extend = extend.right, text = 'POI', text_halign = text.align_left, text_valign = text.align_center, text_color = poi_label_color, text_size = size.small, xloc = xloc.bar_index))

f_sd_to_bos(box_array, bos_array, label_array, zone_type) =>
    if zone_type == 1
        for i = 0 to array.size(box_array) - 1 by 1
            level_to_break = box.get_top(array.get(box_array, i))
            if close >= level_to_break
                copied_box = box.copy(array.get(box_array, i))
                f_array_add_pop(bos_array, copied_box)
                mid = (box.get_top(array.get(box_array, i)) + box.get_bottom(array.get(box_array, i))) / 2
                box.set_top(array.get(bos_array, 0), mid)
                box.set_bottom(array.get(bos_array, 0), mid)
                box.set_extend(array.get(bos_array, 0), extend.none)
                box.set_right(array.get(bos_array, 0), bar_index)
                box.set_text(array.get(bos_array, 0), 'BOS')
                box.set_text_color(array.get(bos_array, 0), bos_label_color)
                box.set_text_size(array.get(bos_array, 0), size.small)
                box.set_text_halign(array.get(bos_array, 0), text.align_center)
                box.set_text_valign(array.get(bos_array, 0), text.align_center)
                box.delete(array.get(box_array, i))
                box.delete(array.get(label_array, i))

    if zone_type == -1
        for i = 0 to array.size(box_array) - 1 by 1
            level_to_break = box.get_bottom(array.get(box_array, i))
            if close <= level_to_break
                copied_box = box.copy(array.get(box_array, i))
                f_array_add_pop(bos_array, copied_box)
                mid = (box.get_top(array.get(box_array, i)) + box.get_bottom(array.get(box_array, i))) / 2
                box.set_top(array.get(bos_array, 0), mid)
                box.set_bottom(array.get(bos_array, 0), mid)
                box.set_extend(array.get(bos_array, 0), extend.none)
                box.set_right(array.get(bos_array, 0), bar_index)
                box.set_text(array.get(bos_array, 0), 'CHOCH')
                box.set_text_color(array.get(bos_array, 0), bos_label_color)
                box.set_text_size(array.get(bos_array, 0), size.small)
                box.set_text_halign(array.get(bos_array, 0), text.align_center)
                box.set_text_valign(array.get(bos_array, 0), text.align_center)
                box.delete(array.get(box_array, i))
                box.delete(array.get(label_array, i))

f_extend_box_endpoint(box_array) =>
    for i = 0 to array.size(box_array) - 1 by 1
        box.set_right(array.get(box_array, i), bar_index + 100)

// MTFTI Functions
get_position(value) =>
    pos = position.middle_right
    if value == 'top_left'
        pos := position.top_left
        pos
    else if value == 'top_right'
        pos := position.top_right
        pos
    else if value == 'middle_left'
        pos := position.middle_left
        pos
    else if value == 'middle_right'
        pos := position.middle_right
        pos
    else if value == 'bottom_left'
        pos := position.bottom_left
        pos
    else if value == 'bottom_right'
        pos := position.bottom_right
        pos
    pos

calcMa(price, length) =>
    float ma = na
    if maType == 'SMA'
        ma := ta.sma(price, length)
        ma
    else if maType == 'EMA'
        ma := ta.ema(price, length)
        ma
    else if maType == 'WMA'
        ma := ta.wma(price, length)
        ma
    else if maType == 'AMA'
        ma := ta.hma(price, length)
        ma
    ma

trendCalc(timeframe) =>
    float maShort = request.security(syminfo.tickerid, timeframe, calcMa(close, shortTerm))
    float maLong = request.security(syminfo.tickerid, timeframe, calcMa(close, longTerm))
    trend = maShort > maLong ? 1 : -1
    trend

// Non-repainting security function
rp_security(_symbol, _res, _src) =>
    request.security(_symbol, _res, _src[barstate.isrealtime ? 1 : 0])

f_chartTfInMinutes() =>
    float _resInMinutes = timeframe.multiplier * (timeframe.isseconds ? 1 : timeframe.isminutes ? 1. : timeframe.isdaily ? 60. * 24 : timeframe.isweekly ? 60. * 24 * 7 : timeframe.ismonthly ? 60. * 24 * 30.4375 : na)
    _resInMinutes

securityNoRep(sym, res, src) =>
    request.security(sym, res, src, barmerge.gaps_off, barmerge.lookahead_on)

equal_tf(res) =>
    str.tonumber(res) == f_chartTfInMinutes() and not timeframe.isseconds
higher_tf(res) =>
    str.tonumber(res) > f_chartTfInMinutes() or timeframe.isseconds
too_small_tf(res) =>
    timeframe.isweekly and res == '1' or timeframe.ismonthly and str.tonumber(res) < 10

securityNoRep1(sym, res, src) =>
    bool bull_ = false
    bull_ := equal_tf(res) ? src : bull_
    bull_ := higher_tf(res) ? request.security(sym, res, src, barmerge.gaps_off, barmerge.lookahead_on) : bull_
    bull_array = request.security_lower_tf(syminfo.tickerid, higher_tf(res) ? str.tostring(f_chartTfInMinutes()) + (timeframe.isseconds ? 'S' : '') : too_small_tf(res) ? timeframe.isweekly ? '3' : '10' : res, src)
    if array.size(bull_array) > 1 and not equal_tf(res) and not higher_tf(res)
        bull_ := array.pop(bull_array)
    array.clear(bull_array)
    bull_
//===== /FUNCTIONS =====

//===== VARIABLES AND CALCULATIONS =====
// Source
src = h ? request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, close, lookahead = barmerge.lookahead_off) : close

// Candlestick Pattern Variables
C_DownTrend = true
C_UpTrend = true

if candlestick_trendRule == "SMA50"
    priceAvg = ta.sma(close, 50)
    C_DownTrend := close < priceAvg
    C_UpTrend := close > priceAvg

if candlestick_trendRule == "SMA50, SMA200"
    sma200 = ta.sma(close, 200)
    sma50 = ta.sma(close, 50)
    C_DownTrend := close < sma50 and sma50 < sma200
    C_UpTrend := close > sma50 and sma50 > sma200

C_Len = 14 // ta.ema depth for bodyAvg
C_ShadowPercent = 5.0 // size of shadows
C_ShadowEqualsPercent = 100.0
C_DojiBodyPercent = 5.0
C_Factor = 2.0 // shows the number of times the shadow dominates the candlestick body

C_BodyHi = math.max(close, open)
C_BodyLo = math.min(close, open)
C_Body = C_BodyHi - C_BodyLo
C_BodyAvg = ta.ema(C_Body, C_Len)
C_SmallBody = C_Body < C_BodyAvg
C_LongBody = C_Body > C_BodyAvg
C_UpShadow = high - C_BodyHi
C_DnShadow = C_BodyLo - low
C_HasUpShadow = C_UpShadow > C_ShadowPercent / 100 * C_Body
C_HasDnShadow = C_DnShadow > C_ShadowPercent / 100 * C_Body
C_WhiteBody = open < close
C_BlackBody = open > close
C_Range = high-low
C_IsInsideBar = C_BodyHi[1] > C_BodyHi and C_BodyLo[1] < C_BodyLo
C_BodyMiddle = C_Body / 2 + C_BodyLo
C_ShadowEquals = C_UpShadow == C_DnShadow or (math.abs(C_UpShadow - C_DnShadow) / C_DnShadow * 100) < C_ShadowEqualsPercent and (math.abs(C_DnShadow - C_UpShadow) / C_UpShadow * 100) < C_ShadowEqualsPercent
C_IsDojiBody = C_Range > 0 and C_Body <= C_Range * C_DojiBodyPercent / 100
C_Doji = C_IsDojiBody and C_ShadowEquals

patternLabelPosLow = low - (ta.atr(30) * 0.6)
patternLabelPosHigh = high + (ta.atr(30) * 0.6)

// Supply/Demand Variables
atr = ta.atr(50)
swing_high = ta.pivothigh(high, swing_length, swing_length)
swing_low = ta.pivotlow(low, swing_length, swing_length)

var swing_high_values = array.new_float(5, 0.00)
var swing_low_values = array.new_float(5, 0.00)

var swing_high_bns = array.new_int(5, 0)
var swing_low_bns = array.new_int(5, 0)

var current_supply_box = array.new_box(history_of_demand_to_keep, na)
var current_demand_box = array.new_box(history_of_demand_to_keep, na)

var current_supply_poi = array.new_box(history_of_demand_to_keep, na)
var current_demand_poi = array.new_box(history_of_demand_to_keep, na)

var supply_bos = array.new_box(5, na)
var demand_bos = array.new_box(5, na)

// SAIYAN OCC Variables
closeSeries = variant(basisType, close[delayOffset], basisLen, offsetSigma, offsetALMA)
openSeries = variant(basisType, open[delayOffset], basisLen, offsetSigma, offsetALMA)

// Get Alternate resolution Series if selected
closeSeriesAlt = reso(closeSeries, useRes, stratRes)
openSeriesAlt = reso(openSeries, useRes, stratRes)

// MTFTI Variables
tf1 = '1'
tf2 = '2'
tf3 = '3'
tf4 = '5'
tf5 = '10'
tf6 = '15'
tf7 = '30'
tf8 = '60'
tf9 = '120'
tf10 = '240'
tf11 = '360'
tf12 = '720'
tf13 = '1440'
tf14 = '1W'

float trend1 = na
float trend2 = na
float trend3 = na
float trend4 = na
float trend5 = na
float trend6 = na
float trend7 = na
float trend8 = na
float trend9 = na
float trend10 = na
float trend11 = na
float trend12 = na
float trend13 = na
float trend14 = na

// Initialize trendSum and activeTfs and Calculate trends for each timeframe
trendSum = 0.0
activeTfs = 0
if showTf1
    trend1 := trendCalc(tf1)
    trendSum := trendSum + trend1
    activeTfs := activeTfs + 1

if showTf2
    trend2 := trendCalc(tf2)
    trendSum := trendSum + trend2
    activeTfs := activeTfs + 1

if showTf3
    trend3 := trendCalc(tf3)
    trendSum := trendSum + trend3
    activeTfs := activeTfs + 1

if showTf4
    trend4 := trendCalc(tf4)
    trendSum := trendSum + trend4
    activeTfs := activeTfs + 1

if showTf5
    trend5 := trendCalc(tf5)
    trendSum := trendSum + trend5
    activeTfs := activeTfs + 1

if showTf6
    trend6 := trendCalc(tf6)
    trendSum := trendSum + trend6
    activeTfs := activeTfs + 1

if showTf7
    trend7 := trendCalc(tf7)
    trendSum := trendSum + trend7
    activeTfs := activeTfs + 1

if showTf8
    trend8 := trendCalc(tf8)
    trendSum := trendSum + trend8
    activeTfs := activeTfs + 1

if showTf9
    trend9 := trendCalc(tf9)
    trendSum := trendSum + trend9
    activeTfs := activeTfs + 1

if showTf10
    trend10 := trendCalc(tf10)
    trendSum := trendSum + trend10
    activeTfs := activeTfs + 1

if showTf11
    trend11 := trendCalc(tf11)
    trendSum := trendSum + trend11
    activeTfs := activeTfs + 1

if showTf12
    trend12 := trendCalc(tf12)
    trendSum := trendSum + trend12
    activeTfs := activeTfs + 1

if showTf13
    trend13 := trendCalc(tf13)
    trendSum := trendSum + trend13
    activeTfs := activeTfs + 1

if showTf14
    trend14 := trendCalc(tf14)
    trendSum := trendSum + trend14
    activeTfs := activeTfs + 1

// Calculate average trend
trendAvg = activeTfs != 0 ? trendSum / activeTfs : na

// Channel Components
ocAvg = math.avg(open, close)
sma1 = ta.sma(close, 5)
sma2 = ta.sma(close, 6)
sma3 = ta.sma(close, 7)
sma4 = ta.sma(close, 8)
sma5 = ta.sma(close, 9)
sma6 = ta.sma(close, 10)
sma7 = ta.sma(close, 11)
sma8 = ta.sma(close, 12)
sma9 = ta.sma(close, 13)
sma10 = ta.sma(close, 14)
sma11 = ta.sma(close, 15)
sma12 = ta.sma(close, 16)
sma13 = ta.sma(close, 17)
sma14 = ta.sma(close, 18)
sma15 = ta.sma(close, 19)
sma16 = ta.sma(close, 20)
psar = ta.sar(0.02, 0.02, 0.2)
[middleKC1, upperKC1, lowerKC1] = ta.kc(close, 80, 10.5)
[middleKC2, upperKC2, lowerKC2] = ta.kc(close, 80, 9.5)
[middleKC3, upperKC3, lowerKC3] = ta.kc(close, 80, 8)
[middleKC4, upperKC4, lowerKC4] = ta.kc(close, 80, 3)

// Colors
green = #00d9ff
green2 = #00d9ff
red = #ff0090
red2 = #ff0090

// Calculate MTFTI moving averages
maShort = calcMa(close, shortTerm)
maLong = calcMa(close, longTerm)
maLongLong = calcMa(close, longLongTerm)
maLongLongLong = calcMa(close, longLongLongTerm)

// Calculate SAIYAN Strategy signals
xlong = ta.crossover(closeSeriesAlt, openSeriesAlt)
xshort = ta.crossunder(closeSeriesAlt, openSeriesAlt)
longCond = xlong
shortCond = xshort
buy = xlong
sell = xshort

// Set up TP/SL parameters
TP = tpPoints > 0 ? tpPoints : na
SL = slPoints > 0 ? slPoints : na

// Calculate time since last bar (for testing)
tdays = (timenow - time) / 60000.0
tdays := timeframe.ismonthly ? tdays / 1440.0 / 5.0 / 4.3 / timeframe.multiplier : timeframe.isweekly ? tdays / 1440.0 / 5.0 / timeframe.multiplier : timeframe.isdaily ? tdays / 1440.0 / timeframe.multiplier : tdays / timeframe.multiplier

// Get HTF security values
htfHigh = rp_security(syminfo.tickerid, res, high)
htfLow = rp_security(syminfo.tickerid, res, low)

// MTFTI trend text
trendAvgText = ''
trendAvgBgcolor = color.silver
if trendAvg <= -0.8
    trendAvgText := 'Strong Down'
    trendAvgBgcolor := colorStrongDown
else if trendAvg <= -0.2
    trendAvgText := 'Down'
    trendAvgBgcolor := colorDown
else if trendAvg >= 0.8
    trendAvgText := 'Strong Up'
    trendAvgBgcolor := colorStrongUp
else if trendAvg >= 0.2
    trendAvgText := 'Up'
    trendAvgBgcolor := colorUp
else
    trendAvgText := 'Neutral'
    trendAvgBgcolor := color.rgb(170, 169, 169)

// Candlestick Pattern Detection
// On Neck - Bearish
C_OnNeckBearish = false
if C_DownTrend and C_BlackBody[1] and C_LongBody[1] and C_WhiteBody and open < close[1] and C_SmallBody and C_Range!=0 and math.abs(close-low[1])<=C_BodyAvg*0.05
    C_OnNeckBearish := true

// Rising Window - Bullish
C_RisingWindowBullish = false
if C_UpTrend[1] and (C_Range!=0 and C_Range[1]!=0) and low > high[1]
    C_RisingWindowBullish := true

// Falling Window - Bearish
C_FallingWindowBearish = false
if C_DownTrend[1] and (C_Range!=0 and C_Range[1]!=0) and high < low[1]
    C_FallingWindowBearish := true

// Falling Three Methods - Bearish
C_FallingThreeMethodsBearish = false
if C_DownTrend[4] and (C_LongBody[4] and C_BlackBody[4]) and (C_SmallBody[3] and C_WhiteBody[3] and open[3]>low[4] and close[3]<high[4]) and (C_SmallBody[2] and C_WhiteBody[2] and open[2]>low[4] and close[2]<high[4]) and (C_SmallBody[1] and C_WhiteBody[1] and open[1]>low[4] and close[1]<high[4]) and (C_LongBody and C_BlackBody and close<close[4])
    C_FallingThreeMethodsBearish := true

// Rising Three Methods - Bullish
C_RisingThreeMethodsBullish = false
if C_UpTrend[4] and (C_LongBody[4] and C_WhiteBody[4]) and (C_SmallBody[3] and C_BlackBody[3] and open[3]<high[4] and close[3]>low[4]) and (C_SmallBody[2] and C_BlackBody[2] and open[2]<high[4] and close[2]>low[4]) and (C_SmallBody[1] and C_BlackBody[1] and open[1]<high[4] and close[1]>low[4]) and (C_LongBody and C_WhiteBody and close>close[4])
    C_RisingThreeMethodsBullish := true

// Tweezer Top - Bearish
C_TweezerTopBearish = false
if C_UpTrend[1] and (not C_IsDojiBody or (C_HasUpShadow and C_HasDnShadow)) and math.abs(high-high[1]) <= C_BodyAvg*0.05 and C_WhiteBody[1] and C_BlackBody and C_LongBody[1]
    C_TweezerTopBearish := true

// Tweezer Bottom - Bullish
C_TweezerBottomBullish = false
if C_DownTrend[1] and (not C_IsDojiBody or (C_HasUpShadow and C_HasDnShadow)) and math.abs(low-low[1]) <= C_BodyAvg*0.05 and C_BlackBody[1] and C_WhiteBody and C_LongBody[1]
    C_TweezerBottomBullish := true

// Dark Cloud Cover - Bearish
C_DarkCloudCoverBearish = false
if (C_UpTrend[1] and C_WhiteBody[1] and C_LongBody[1]) and (C_BlackBody and open >= high[1] and close < C_BodyMiddle[1] and close > open[1])
    C_DarkCloudCoverBearish := true

// Downside Tasuki Gap - Bearish
C_DownsideTasukiGapBearish = false
if C_LongBody[2] and C_SmallBody[1] and C_DownTrend and C_BlackBody[2] and C_BodyHi[1] < C_BodyLo[2] and C_BlackBody[1] and C_WhiteBody and C_BodyHi <= C_BodyLo[2] and C_BodyHi >= C_BodyHi[1]
    C_DownsideTasukiGapBearish := true

// Upside Tasuki Gap - Bullish
C_UpsideTasukiGapBullish = false
if C_LongBody[2] and C_SmallBody[1] and C_UpTrend and C_WhiteBody[2] and C_BodyLo[1] > C_BodyHi[2] and C_WhiteBody[1] and C_BlackBody and C_BodyLo >= C_BodyHi[2] and C_BodyLo <= C_BodyLo[1]
    C_UpsideTasukiGapBullish := true

// Evening Doji Star - Bearish
C_EveningDojiStarBearish = false
if C_LongBody[2] and C_IsDojiBody[1] and C_LongBody and C_UpTrend and C_WhiteBody[2] and C_BodyLo[1] > C_BodyHi[2] and C_BlackBody and C_BodyLo <= C_BodyMiddle[2] and C_BodyLo > C_BodyLo[2] and C_BodyLo[1] > C_BodyHi
    C_EveningDojiStarBearish := true

// Doji Star - Bearish
C_DojiStarBearish = false
if C_UpTrend and C_WhiteBody[1] and C_LongBody[1] and C_IsDojiBody and C_BodyLo > C_BodyHi[1]
    C_DojiStarBearish := true

// Doji Star - Bullish
C_DojiStarBullish = false
if C_DownTrend and C_BlackBody[1] and C_LongBody[1] and C_IsDojiBody and C_BodyHi < C_BodyLo[1]
    C_DojiStarBullish := true

// Morning Doji Star - Bullish
C_MorningDojiStarBullish = false
if C_LongBody[2] and C_IsDojiBody[1] and C_LongBody and C_DownTrend and C_BlackBody[2] and C_BodyHi[1] < C_BodyLo[2] and C_WhiteBody and C_BodyHi >= C_BodyMiddle[2] and C_BodyHi < C_BodyHi[2] and C_BodyHi[1] < C_BodyLo
    C_MorningDojiStarBullish := true

// Piercing - Bullish
C_PiercingBullish = false
if (C_DownTrend[1] and C_BlackBody[1] and C_LongBody[1]) and (C_WhiteBody and open <= low[1] and close > C_BodyMiddle[1] and close < open[1])
    C_PiercingBullish := true

// Hammer - Bullish
C_HammerBullish = false
if C_SmallBody and C_Body > 0 and C_BodyLo > hl2 and C_DnShadow >= C_Factor * C_Body and not C_HasUpShadow
    if C_DownTrend
        C_HammerBullish := true

// Hanging Man - Bearish
C_HangingManBearish = false
if C_SmallBody and C_Body > 0 and C_BodyLo > hl2 and C_DnShadow >= C_Factor * C_Body and not C_HasUpShadow
    if C_UpTrend
        C_HangingManBearish := true

// Shooting Star - Bearish
C_ShootingStarBearish = false
if C_SmallBody and C_Body > 0 and C_BodyHi < hl2 and C_UpShadow >= C_Factor * C_Body and not C_HasDnShadow
    if C_UpTrend
        C_ShootingStarBearish := true

// Inverted Hammer - Bullish
C_InvertedHammerBullish = false
if C_SmallBody and C_Body > 0 and C_BodyHi < hl2 and C_UpShadow >= C_Factor * C_Body and not C_HasDnShadow
    if C_DownTrend
        C_InvertedHammerBullish := true

// Morning Star - Bullish
C_MorningStarBullish = false
if C_LongBody[2] and C_SmallBody[1] and C_LongBody
    if C_DownTrend and C_BlackBody[2] and C_BodyHi[1] < C_BodyLo[2] and C_WhiteBody and C_BodyHi >= C_BodyMiddle[2] and C_BodyHi < C_BodyHi[2] and C_BodyHi[1] < C_BodyLo
        C_MorningStarBullish := true

// Evening Star - Bearish
C_EveningStarBearish = false
if C_LongBody[2] and C_SmallBody[1] and C_LongBody
    if C_UpTrend and C_WhiteBody[2] and C_BodyLo[1] > C_BodyHi[2] and C_BlackBody and C_BodyLo <= C_BodyMiddle[2] and C_BodyLo > C_BodyLo[2] and C_BodyLo[1] > C_BodyHi
        C_EveningStarBearish := true

// Marubozu White - Bullish
C_MarubozuShadowPercentWhite = 5.0
C_MarubozuWhiteBullish = C_WhiteBody and C_LongBody and C_UpShadow <= C_MarubozuShadowPercentWhite/100*C_Body and C_DnShadow <= C_MarubozuShadowPercentWhite/100*C_Body and C_WhiteBody

// Marubozu Black - Bearish
C_MarubozuShadowPercentBearish = 5.0
C_MarubozuBlackBearish = C_BlackBody and C_LongBody and C_UpShadow <= C_MarubozuShadowPercentBearish/100*C_Body and C_DnShadow <= C_MarubozuShadowPercentBearish/100*C_Body and C_BlackBody

// Doji, Dragonfly Doji, Gravestone Doji
C_DragonflyDoji = C_IsDojiBody and C_UpShadow <= C_Body
C_GravestoneDojiOne = C_IsDojiBody and C_DnShadow <= C_Body

// Gravestone Doji - Bearish
C_GravestoneDojiBearish = C_IsDojiBody and C_DnShadow <= C_Body

// Dragonfly Doji - Bullish
C_DragonflyDojiBullish = C_IsDojiBody and C_UpShadow <= C_Body

// Harami Cross - Bullish
C_HaramiCrossBullish = C_LongBody[1] and C_BlackBody[1] and C_DownTrend[1] and C_IsDojiBody and high <= C_BodyHi[1] and low >= C_BodyLo[1]

// Harami Cross - Bearish
C_HaramiCrossBearish = C_LongBody[1] and C_WhiteBody[1] and C_UpTrend[1] and C_IsDojiBody and high <= C_BodyHi[1] and low >= C_BodyLo[1]

// Harami - Bullish
C_HaramiBullish = C_LongBody[1] and C_BlackBody[1] and C_DownTrend[1] and C_WhiteBody and C_SmallBody and high <= C_BodyHi[1] and low >= C_BodyLo[1]

// Harami - Bearish
C_HaramiBearish = C_LongBody[1] and C_WhiteBody[1] and C_UpTrend[1] and C_BlackBody and C_SmallBody and high <= C_BodyHi[1] and low >= C_BodyLo[1]

// Long Lower Shadow - Bullish
C_LongLowerShadowPercent = 75.0
C_LongLowerShadowBullish = C_DnShadow > C_Range/100*C_LongLowerShadowPercent

// Long Upper Shadow - Bearish
C_LongShadowPercent = 75.0
C_LongUpperShadowBearish = C_UpShadow > C_Range/100*C_LongShadowPercent

// Spinning Top White
C_SpinningTopWhitePercent = 34.0
C_IsSpinningTopWhite = C_DnShadow >= C_Range / 100 * C_SpinningTopWhitePercent and C_UpShadow >= C_Range / 100 * C_SpinningTopWhitePercent and not C_IsDojiBody
C_SpinningTopWhite = C_IsSpinningTopWhite and C_WhiteBody

// Spinning Top Black
C_SpinningTopBlackPercent = 34.0
C_IsSpinningTop = C_DnShadow >= C_Range / 100 * C_SpinningTopBlackPercent and C_UpShadow >= C_Range / 100 * C_SpinningTopBlackPercent and not C_IsDojiBody
C_SpinningTopBlack = C_IsSpinningTop and C_BlackBody

// Three White Soldiers - Bullish
C_3WSld_ShadowPercent = 5.0
C_3WSld_HaveNotUpShadow = C_Range * C_3WSld_ShadowPercent / 100 > C_UpShadow
C_ThreeWhiteSoldiersBullish = false
if C_LongBody and C_LongBody[1] and C_LongBody[2]
    if C_WhiteBody and C_WhiteBody[1] and C_WhiteBody[2]
        C_ThreeWhiteSoldiersBullish := close > close[1] and close[1] > close[2] and open < close[1] and open > open[1] and open[1] < close[2] and open[1] > open[2] and C_3WSld_HaveNotUpShadow and C_3WSld_HaveNotUpShadow[1] and C_3WSld_HaveNotUpShadow[2]

// Three Black Crows - Bearish
C_3BCrw_ShadowPercent = 5.0
C_3BCrw_HaveNotDnShadow = C_Range * C_3BCrw_ShadowPercent / 100 > C_DnShadow
C_ThreeBlackCrowsBearish = false
if C_LongBody and C_LongBody[1] and C_LongBody[2]
    if C_BlackBody and C_BlackBody[1] and C_BlackBody[2]
        C_ThreeBlackCrowsBearish := close < close[1] and close[1] < close[2] and open > close[1] and open < open[1] and open[1] > close[2] and open[1] < open[2] and C_3BCrw_HaveNotDnShadow and C_3BCrw_HaveNotDnShadow[1] and C_3BCrw_HaveNotDnShadow[2]

// Engulfing - Bullish
C_EngulfingBullish = C_DownTrend and C_WhiteBody and C_LongBody and C_BlackBody[1] and C_SmallBody[1] and close >= open[1] and open <= close[1] and (close > open[1] or open < close[1])

// Engulfing - Bearish
C_EngulfingBearish = C_UpTrend and C_BlackBody and C_LongBody and C_WhiteBody[1] and C_SmallBody[1] and close <= open[1] and open >= close[1] and (close < open[1] or open > close[1])

// Abandoned Baby - Bullish
C_AbandonedBabyBullish = C_DownTrend[2] and C_BlackBody[2] and C_IsDojiBody[1] and low[2] > high[1] and C_WhiteBody and high[1] < low

// Abandoned Baby - Bearish
C_AbandonedBabyBearish = C_UpTrend[2] and C_WhiteBody[2] and C_IsDojiBody[1] and high[2] < low[1] and C_BlackBody and low[1] > high

// Tri-Star - Bullish
C_3DojisBullish = C_Doji[2] and C_Doji[1] and C_Doji
C_BodyGapUpBullish = C_BodyHi[1] < C_BodyLo
C_BodyGapDnBullish = C_BodyLo[1] > C_BodyHi
C_TriStarBullish = C_3DojisBullish and C_DownTrend[2] and C_BodyGapDnBullish[1] and C_BodyGapUpBullish

// Tri-Star - Bearish
C_3Dojis = C_Doji[2] and C_Doji[1] and C_Doji
C_BodyGapUp = C_BodyHi[1] < C_BodyLo
C_BodyGapDn = C_BodyLo[1] > C_BodyHi
C_TriStarBearish = C_3Dojis and C_UpTrend[2] and C_BodyGapUp[1] and C_BodyGapDn

// Kicking - Bullish
C_MarubozuShadowPercent = 5.0
C_Marubozu = C_LongBody and C_UpShadow <= C_MarubozuShadowPercent/100*C_Body and C_DnShadow <= C_MarubozuShadowPercent/100*C_Body
C_MarubozuWhiteBullishKicking = C_Marubozu and C_WhiteBody
C_MarubozuBlackBullish = C_Marubozu and C_BlackBody
C_KickingBullish = C_MarubozuBlackBullish[1] and C_MarubozuWhiteBullishKicking and high[1] < low

// Kicking - Bearish
C_MarubozuBullishShadowPercent = 5.0
C_MarubozuBearishKicking = C_LongBody and C_UpShadow <= C_MarubozuBullishShadowPercent/100*C_Body and C_DnShadow <= C_MarubozuBullishShadowPercent/100*C_Body
C_MarubozuWhiteBearish = C_MarubozuBearishKicking and C_WhiteBody
C_MarubozuBlackBearishKicking = C_MarubozuBearishKicking and C_BlackBody
C_KickingBearish = C_MarubozuWhiteBearish[1] and C_MarubozuBlackBearishKicking and low[1] > high

// Aggregated bullish and bearish signals
bullish_patterns = C_RisingWindowBullish or C_RisingThreeMethodsBullish or C_TweezerBottomBullish or 
                   C_UpsideTasukiGapBullish or C_DojiStarBullish or C_MorningDojiStarBullish or 
                   C_PiercingBullish or C_HammerBullish or C_InvertedHammerBullish or C_MorningStarBullish or 
                   C_MarubozuWhiteBullish or C_DragonflyDojiBullish or C_HaramiCrossBullish or 
                   C_HaramiBullish or C_LongLowerShadowBullish or C_ThreeWhiteSoldiersBullish or 
                   C_EngulfingBullish or C_AbandonedBabyBullish or C_TriStarBullish or C_KickingBullish

bearish_patterns = C_OnNeckBearish or C_FallingWindowBearish or C_FallingThreeMethodsBearish or 
                   C_TweezerTopBearish or C_DarkCloudCoverBearish or C_DownsideTasukiGapBearish or 
                   C_EveningDojiStarBearish or C_DojiStarBearish or C_HangingManBearish or C_ShootingStarBearish or 
                   C_EveningStarBearish or C_MarubozuBlackBearish or C_GravestoneDojiBearish or 
                   C_HaramiCrossBearish or C_HaramiBearish or C_LongUpperShadowBearish or C_ThreeBlackCrowsBearish or 
                   C_EngulfingBearish or C_AbandonedBabyBearish or C_TriStarBearish or C_KickingBearish
//===== /VARIABLES AND CALCULATIONS =====

//===== LOGIC =====
// Process Supply/Demand zones
if not na(swing_high)
    // Manage swing high values
    f_array_add_pop(swing_high_values, swing_high)
    f_array_add_pop(swing_high_bns, bar_index[swing_length])
    if show_price_action_labels
        f_sh_sl_labels(swing_high_values, 1)
    f_supply_demand(swing_high_values, swing_high_bns, current_supply_box, current_supply_poi, 1, atr)

else if not na(swing_low)
    // Manage swing low values
    f_array_add_pop(swing_low_values, swing_low)
    f_array_add_pop(swing_low_bns, bar_index[swing_length])
    if show_price_action_labels
        f_sh_sl_labels(swing_low_values, -1)
    f_supply_demand(swing_low_values, swing_low_bns, current_demand_box, current_demand_poi, -1, atr)

// Check for BOS (Break of Structure)
f_sd_to_bos(current_supply_box, supply_bos, current_supply_poi, 1)
f_sd_to_bos(current_demand_box, demand_bos, current_demand_poi, -1)

// Extend Supply/Demand boxes to the right
f_extend_box_endpoint(current_supply_box)
f_extend_box_endpoint(current_demand_box)

// Create MTFTI table
trendTable = table.new(position = get_position(tablePosition), columns = 2, rows = 16, frame_color = color.white, bgcolor = color.black)

// Add header cell with left alignment
table.cell(trendTable, column = 0, row = 0, text = 'Trend', bgcolor = color.black, text_color = color.white)
table.cell(trendTable, column = 1, row = 0, text = 'TF', bgcolor = color.black, text_color = color.white)

// Fill table cells with trend information
if showTf1
    table.cell(trendTable, column = 1, row = 1, text = '1', bgcolor = color.rgb(0, 0, 0, 70), text_color = color.white)
    table.cell(trendTable, column = 0, row = 1, text = trend1 > 0 ? 'Up' : 'Down', bgcolor = trend1 > 0 ? colorUp : colorDown)

if showTf2
    table.cell(trendTable, column = 1, row = 2, text = '2', bgcolor = color.rgb(0, 0, 0, 70), text_color = color.white)
    table.cell(trendTable, column = 0, row = 2, text = trend2 > 0 ? 'Up' : 'Down', bgcolor = trend2 > 0 ? colorUp : colorDown)

if showTf3
    table.cell(trendTable, column = 1, row = 3, text = '3', bgcolor = color.rgb(0, 0, 0, 70), text_color = color.white)
    table.cell(trendTable, column = 0, row = 3, text = trend3 > 0 ? 'Up' : 'Down', bgcolor = trend3 > 0 ? colorUp : colorDown)

if showTf4
    table.cell(trendTable, column = 1, row = 4, text = '5', bgcolor = color.rgb(0, 0, 0, 70), text_color = color.white)
    table.cell(trendTable, column = 0, row = 4, text = trend4 > 0 ? 'Up' : 'Down', bgcolor = trend4 > 0 ? colorUp : colorDown)

if showTf5
    table.cell(trendTable, column = 1, row = 5, text = '10', bgcolor = color.rgb(0, 0, 0, 70), text_color = color.white)
    table.cell(trendTable, column = 0, row = 5, text = trend5 > 0 ? 'Up' : 'Down', bgcolor = trend5 > 0 ? colorUp : colorDown)

if showTf6
    table.cell(trendTable, column = 1, row = 6, text = '15', bgcolor = color.rgb(0, 0, 0, 70), text_color = color.white)
    table.cell(trendTable, column = 0, row = 6, text = trend6 > 0 ? 'Up' : 'Down', bgcolor = trend6 > 0 ? colorUp : colorDown)

if showTf7
    table.cell(trendTable, column = 1, row = 7, text = '30', bgcolor = color.rgb(0, 0, 0, 70), text_color = color.white)
    table.cell(trendTable, column = 0, row = 7, text = trend7 > 0 ? 'Up' : 'Down', bgcolor = trend7 > 0 ? colorUp : colorDown)

if showTf8
    table.cell(trendTable, column = 1, row = 8, text = '1H', bgcolor = color.rgb(0, 0, 0, 70), text_color = color.white)
    table.cell(trendTable, column = 0, row = 8, text = trend8 > 0 ? 'Up' : 'Down', bgcolor = trend8 > 0 ? colorUp : colorDown)

if showTf9
    table.cell(trendTable, column = 1, row = 9, text = '2H', bgcolor = color.rgb(0, 0, 0, 70), text_color = color.white)
    table.cell(trendTable, column = 0, row = 9, text = trend9 > 0 ? 'Up' : 'Down', bgcolor = trend9 > 0 ? colorUp : colorDown)

if showTf10
    table.cell(trendTable, column = 1, row = 10, text = '4H', bgcolor = color.rgb(0, 0, 0, 70), text_color = color.white)
    table.cell(trendTable, column = 0, row = 10, text = trend10 > 0 ? 'Up' : 'Down', bgcolor = trend10 > 0 ? colorUp : colorDown)

if showTf11
    table.cell(trendTable, column = 1, row = 11, text = '6H', bgcolor = color.rgb(0, 0, 0, 70), text_color = color.white)
    table.cell(trendTable, column = 0, row = 11, text = trend11 > 0 ? 'Up' : 'Down', bgcolor = trend11 > 0 ? colorUp : colorDown)

if showTf12
    table.cell(trendTable, column = 1, row = 12, text = '12H', bgcolor = color.rgb(0, 0, 0, 70), text_color = color.white)
    table.cell(trendTable, column = 0, row = 12, text = trend12 > 0 ? 'Up' : 'Down', bgcolor = trend12 > 0 ? colorUp : colorDown)

if showTf13
    table.cell(trendTable, column = 1, row = 13, text = '1D', bgcolor = color.rgb(0, 0, 0, 70), text_color = color.white)
    table.cell(trendTable, column = 0, row = 13, text = trend13 > 0 ? 'Up' : 'Down', bgcolor = trend13 > 0 ? colorUp : colorDown)

if showTf14
    table.cell(trendTable, column = 1, row = 14, text = '1W', bgcolor = color.rgb(0, 0, 0, 70), text_color = color.white)
    table.cell(trendTable, column = 0, row = 14, text = trend14 > 0 ? 'Up' : 'Down', bgcolor = trend14 > 0 ? colorUp : colorDown)

if showTf15
    table.cell(trendTable, column = 1, row = 15, text = 'AVG', bgcolor = color.rgb(0, 0, 0, 70), text_color = color.white)
    table.cell(trendTable, column = 0, row = 15, text = trendAvgText, bgcolor = trendAvgBgcolor)

// Display Candlestick Pattern Labels if enabled
if use_candlestick_patterns
    // On Neck - Bearish
    if C_OnNeckBearish and OnNeckInput and (("Bearish" == CandleType) or CandleType == "Both")
        var ttBearishOnNeck = "On Neck\nOn Neck is a two-line continuation pattern found in a downtrend. The first candle is long and red, the second candle is short and has a green body. The closing price of the second candle is close or equal to the first candle's low price. The pattern hints at a continuation of a downtrend, and penetrating the low of the green candlestick is sometimes considered a confirmation."
        label.new(bar_index, patternLabelPosHigh, text="ON", style=label.style_label_down, color = label_color_bearish, textcolor=color.white, tooltip = ttBearishOnNeck)

    // Rising Window - Bullish
    if C_RisingWindowBullish and RisingWindowInput and (("Bullish" == CandleType) or CandleType == "Both")
        var ttBullishRisingWindow = "Rising Window\nRising Window is a two-candle bullish continuation pattern that forms during an uptrend. Both candles in the pattern can be of any type with the exception of the Four-Price Doji. The most important characteristic of the pattern is a price gap between the first candle's high and the second candle's low. That gap (window) between two bars signifies support against the selling pressure."
        label.new(bar_index, patternLabelPosLow, text="RW", style=label.style_label_up, color = label_color_bullish, textcolor=color.white, tooltip = ttBullishRisingWindow)

    // Falling Window - Bearish
    if C_FallingWindowBearish and FallingWindowInput and (("Bearish" == CandleType) or CandleType == "Both")
        var ttBearishFallingWindow = "Falling Window\nFalling Window is a two-candle bearish continuation pattern that forms during a downtrend. Both candles in the pattern can be of any type, with the exception of the Four-Price Doji. The most important characteristic of the pattern is a price gap between the first candle's low and the second candle's high. The existence of this gap (window) means that the bearish trend is expected to continue."
        label.new(bar_index, patternLabelPosHigh, text="FW", style=label.style_label_down, color = label_color_bearish, textcolor=color.white, tooltip = ttBearishFallingWindow)

    // Falling Three Methods - Bearish
    if C_FallingThreeMethodsBearish and FallingThreeMethodsInput and (("Bearish" == CandleType) or CandleType == "Both")
        var ttBearishFallingThreeMethods = "Falling Three Methods\nFalling Three Methods is a five-candle bearish pattern that signifies a continuation of an existing downtrend. The first candle is long and red, followed by three short green candles with bodies inside the range of the first candle. The last candle is also red and long and it closes below the close of the first candle. This decisive fifth strongly bearish candle hints that bulls could not reverse the prior downtrend and that bears have regained control of the market."
        label.new(bar_index, patternLabelPosHigh, text="FTM", style=label.style_label_down, color = label_color_bearish, textcolor=color.white, tooltip = ttBearishFallingThreeMethods)

    // Rising Three Methods - Bullish
    if C_RisingThreeMethodsBullish and RisingThreeMethodsInput and (("Bullish" == CandleType) or CandleType == "Both")
        var ttBullishRisingThreeMethods = "Rising Three Methods\nRising Three Methods is a five-candle bullish pattern that signifies a continuation of an existing uptrend. The first candle is long and green, followed by three short red candles with bodies inside the range of the first candle. The last candle is also green and long and it closes above the close of the first candle. This decisive fifth strongly bullish candle hints that bears could not reverse the prior uptrend and that bulls have regained control of the market."
        label.new(bar_index, patternLabelPosLow, text="RTM", style=label.style_label_up, color = label_color_bullish, textcolor=color.white, tooltip = ttBullishRisingThreeMethods)

    // Tweezer Top - Bearish
    if C_TweezerTopBearish and TweezerTopInput and (("Bearish" == CandleType) or CandleType == "Both")
        var ttBearishTweezerTop = "Tweezer Top\nTweezer Top is a two-candle pattern that signifies a potential bearish reversal. The pattern is found during an uptrend. The first candle is long and green, the second candle is red, and its high is nearly identical to the high of the previous candle. The virtually identical highs, together with the inverted directions, hint that bears might be taking over the market."
        label.new(bar_index, patternLabelPosHigh, text="TT", style=label.style_label_down, color = label_color_bearish, textcolor=color.white, tooltip = ttBearishTweezerTop)

    // Tweezer Bottom - Bullish
    if C_TweezerBottomBullish and TweezerBottomInput and (("Bullish" == CandleType) or CandleType == "Both")
        var ttBullishTweezerBottom = "Tweezer Bottom\nTweezer Bottom is a two-candle pattern that signifies a potential bullish reversal. The pattern is found during a downtrend. The first candle is long and red, the second candle is green, its lows nearly identical to the low of the previous candle. The virtually identical lows together with the inverted directions hint that bulls might be taking over the market."
        label.new(bar_index, patternLabelPosLow, text="TB", style=label.style_label_up, color = label_color_bullish, textcolor=color.white, tooltip = ttBullishTweezerBottom)

    // Dark Cloud Cover - Bearish
    if C_DarkCloudCoverBearish and DarkCloudCoverInput and (("Bearish" == CandleType) or CandleType == "Both")
        var ttBearishDarkCloudCover = "Dark Cloud Cover\nDark Cloud Cover is a two-candle bearish reversal candlestick pattern found in an uptrend. The first candle is green and has a larger than average body. The second candle is red and opens above the high of the prior candle, creating a gap, and then closes below the midpoint of the first candle. The pattern shows a possible shift in the momentum from the upside to the downside, indicating that a reversal might happen soon."
        label.new(bar_index, patternLabelPosHigh, text="DCC", style=label.style_label_down, color = label_color_bearish, textcolor=color.white, tooltip = ttBearishDarkCloudCover)

    // Downside Tasuki Gap - Bearish
    if C_DownsideTasukiGapBearish and DownsideTasukiGapInput and (("Bearish" == CandleType) or CandleType == "Both")
        var ttBearishDownsideTasukiGap = "Downside Tasuki Gap\nDownside Tasuki Gap is a three-candle pattern found in a downtrend that usually hints at the continuation of the downtrend. The first candle is long and red, followed by a smaller red candle with its opening price that gaps below the body of the previous candle. The third candle is green and it closes inside the gap created by the first two candles, unable to close it fully. The bull's inability to close that gap hints that the downtrend might continue."
        label.new(bar_index, patternLabelPosHigh, text="DTG", style=label.style_label_down, color = label_color_bearish, textcolor=color.white, tooltip = ttBearishDownsideTasukiGap)

    // Upside Tasuki Gap - Bullish
    if C_UpsideTasukiGapBullish and UpsideTasukiGapInput and (("Bullish" == CandleType) or CandleType == "Both")
        var ttBullishUpsideTasukiGap = "Upside Tasuki Gap\nUpside Tasuki Gap is a three-candle pattern found in an uptrend that usually hints at the continuation of the uptrend. The first candle is long and green, followed by a smaller green candle with its opening price that gaps above the body of the previous candle. The third candle is red and it closes inside the gap created by the first two candles, unable to close it fully. The bear's inability to close the gap hints that the uptrend might continue."
        label.new(bar_index, patternLabelPosLow, text="UTG", style=label.style_label_up, color = label_color_bullish, textcolor=color.white, tooltip = ttBullishUpsideTasukiGap)

    // Evening Doji Star - Bearish
    if C_EveningDojiStarBearish and EveningDojiStarInput and (("Bearish" == CandleType) or CandleType == "Both")
        var ttBearishEveningDojiStar = "Evening Doji Star\nThis candlestick pattern is a variation of the Evening Star pattern. It is bearish and continues an uptrend with a long-bodied, green candle day. It is then followed by a gap and a Doji candle and concludes with a downward close. The close would be below the first day's midpoint. It is more bearish than the regular evening star pattern because of the existence of the Doji."
        label.new(bar_index, patternLabelPosHigh, text="EDS", style=label.style_label_down, color = label_color_bearish, textcolor=color.white, tooltip = ttBearishEveningDojiStar)

    // Doji Star - Bearish
    if C_DojiStarBearish and DojiStarInput and (("Bearish" == CandleType) or CandleType == "Both")
        var ttBearishDojiStar = "Doji Star\nThis is a bearish reversal candlestick pattern that is found in an uptrend and consists of two candles. First comes a long green candle, followed by a Doji candle (except 4-Price Doji) that opens above the body of the first one, creating a gap. It is considered a reversal signal with confirmation during the next trading day."
        label.new(bar_index, patternLabelPosHigh, text="DS", style=label.style_label_down, color = label_color_bearish, textcolor=color.white, tooltip = ttBearishDojiStar)

    // Doji Star - Bullish
    if C_DojiStarBullish and DojiStarInput and (("Bullish" == CandleType) or CandleType == "Both")
        var ttBullishDojiStar = "Doji Star\nThis is a bullish reversal candlestick pattern that is found in a downtrend and consists of two candles. First comes a long red candle, followed by a Doji candle (except 4-Price Doji) that opens below the body of the first one, creating a gap. It is considered a reversal signal with confirmation during the next trading day."
        label.new(bar_index, patternLabelPosLow, text="DS", style=label.style_label_up, color = label_color_bullish, textcolor=color.white, tooltip = ttBullishDojiStar)

    // Morning Doji Star - Bullish
    if C_MorningDojiStarBullish and MorningDojiStarInput and (("Bullish" == CandleType) or CandleType == "Both")
        var ttBullishMorningDojiStar = "Morning Doji Star\nThis candlestick pattern is a variation of the Morning Star pattern. A three-day bullish reversal pattern, which consists of three candlesticks will look something like this: The first being a long-bodied red candle that extends the current downtrend. Next comes a Doji that gaps down on the open. After that comes a long-bodied green candle, which gaps up on the open and closes above the midpoint of the body of the first day. It is more bullish than the regular morning star pattern because of the existence of the Doji."
        label.new(bar_index, patternLabelPosLow, text="MDS", style=label.style_label_up, color = label_color_bullish, textcolor=color.white, tooltip = ttBullishMorningDojiStar)

    // Piercing - Bullish
    if C_PiercingBullish and PiercingInput and (("Bullish" == CandleType) or CandleType == "Both")
        var ttBullishPiercing = "Piercing\nPiercing is a two-candle bullish reversal candlestick pattern found in a downtrend. The first candle is red and has a larger than average body. The second candle is green and opens below the low of the prior candle, creating a gap, and then closes above the midpoint of the first candle. The pattern shows a possible shift in the momentum from the downside to the upside, indicating that a reversal might happen soon."
        label.new(bar_index, patternLabelPosLow, text="P", style=label.style_label_up, color = label_color_bullish, textcolor=color.white, tooltip = ttBullishPiercing)

    // Hammer - Bullish
    if C_HammerBullish and HammerInput and (("Bullish" == CandleType) or CandleType == "Both")
        var ttBullishHammer = "Hammer\nHammer candlesticks form when a security moves lower after the open, but continues to rally into close above the intraday low. The candlestick that you are left with will look like a square attached to a long stick-like figure. This candlestick is called a Hammer if it happens to form during a decline."
        label.new(bar_index, patternLabelPosLow, text="H", style=label.style_label_up, color = label_color_bullish, textcolor=color.white, tooltip = ttBullishHammer)

    // Hanging Man - Bearish
    if C_HangingManBearish and HangingManInput and (("Bearish" == CandleType) or CandleType == "Both")
        var ttBearishHangingMan = "Hanging Man\nWhen a specified security notably moves lower after the open, but continues to rally to close above the intraday low, a Hanging Man candlestick will form. The candlestick will resemble a square, attached to a long stick-like figure. It is referred to as a Hanging Man if the candlestick forms during an advance."
        label.new(bar_index, patternLabelPosHigh, text="HM", style=label.style_label_down, color = label_color_bearish, textcolor=color.white, tooltip = ttBearishHangingMan)

    // Doji
    if C_Doji and not C_DragonflyDoji and not C_GravestoneDojiOne and DojiInput
        var ttDoji = "Doji\nWhen the open and close of a security are essentially equal to each other, a doji candle forms. The length of both upper and lower shadows may vary, causing the candlestick you are left with to either resemble a cross, an inverted cross, or a plus sign. Doji candles show the playout of buyer-seller indecision in a tug-of-war of sorts. As price moves either above or below the opening level during the session, the close is either at or near the opening level."
        label.new(bar_index, patternLabelPosLow, text="D", style=label.style_label_up, color = label_color_neutral, textcolor=color.white, tooltip = ttDoji)
//===== /LOGIC =====

//===== PLOTTING =====
// Plot Moving Averages from MTFTI
plot(showShortTerm ? maShort : na, title = 'Short Term MA', color = color.blue, linewidth = 1)
plot(showLongTerm ? maLong : na, title = 'Long Term MA', color = color.black, linewidth = 1)
plot(showLongLongTerm ? maLongLong : na, title = 'Long Long Term MA', color = color.orange, linewidth = 1)
plot(showLongLongLongTerm ? maLongLongLong : na, title = 'Long Long Long Term MA', color = color.red, linewidth = 1)

// Plot Channel Keltner Channel lines
k1 = plot(ta.ema(upperKC1, 50), '', na, editable = false)
k2 = plot(ta.ema(upperKC2, 50), '', na, editable = false)
k3 = plot(ta.ema(upperKC3, 50), '', na, editable = false)
k4 = plot(ta.ema(upperKC4, 50), '', na, editable = false)
k5 = plot(ta.ema(lowerKC4, 50), '', na, editable = false)
k6 = plot(ta.ema(lowerKC3, 50), '', na, editable = false)
k7 = plot(ta.ema(lowerKC2, 50), '', na, editable = false)
k8 = plot(ta.ema(lowerKC1, 50), '', na, editable = false)

// Fill channels
fill(k1, k2, channelBal ? color.new(red2, 40) : na, editable = false)
fill(k2, k3, channelBal ? color.new(red2, 65) : na, editable = false)
fill(k3, k4, channelBal ? color.new(red2, 90) : na, editable = false)
fill(k5, k6, channelBal ? color.new(green2, 90) : na, editable = false)
fill(k6, k7, channelBal ? color.new(green2, 65) : na, editable = false)
fill(k7, k8, channelBal ? color.new(green2, 40) : na, editable = false)

// Plot buy/sell signals from SAIYAN OCC
plotshape(buy, title = 'Buy', text = 'Buy', style = shape.labelup, location = location.belowbar, color = color.new(color.green, 0), textcolor = color.white, size = size.tiny)
plotshape(sell, title = 'Sell', text = 'Sell', style = shape.labeldown, location = location.abovebar, color = color.new(color.red, 0), textcolor = color.white, size = size.tiny)
//===== /PLOTTING =====

//===== STRATEGY EXECUTION =====
// Enhanced entry signals considering candlestick patterns
enhanced_buy = buy
enhanced_sell = sell

// Consider candlestick patterns for entry if enabled
if use_candlestick_patterns
    enhanced_buy := buy and (not bearish_patterns or CandleType == "Bearish")
    enhanced_sell := sell and (not bullish_patterns or CandleType == "Bullish")

// Enter trades based on SAIYAN OCC signals
if enhanced_buy and (tradeType == 'LONG' or tradeType == 'BOTH')
    strategy.entry('Long', strategy.long, alert_message = i_alert_txt_entry_long)

if enhanced_sell and (tradeType == 'SHORT' or tradeType == 'BOTH')
    strategy.entry('Short', strategy.short, alert_message = i_alert_txt_entry_short)

// Set stop-loss and take-profit if configured
if strategy.position_size > 0 and SL > 0
    strategy.exit("SL/TP Long", "Long", stop = strategy.position_avg_price - SL * syminfo.mintick, limit = TP > 0 ? strategy.position_avg_price + TP * syminfo.mintick : na)

if strategy.position_size < 0 and SL > 0
    strategy.exit("SL/TP Short", "Short", stop = strategy.position_avg_price + SL * syminfo.mintick, limit = TP > 0 ? strategy.position_avg_price - TP * syminfo.mintick : na)

// Alert conditions for MTFTI
alertcondition(trendAvg <= -0.8, title = 'Strong Down Alert', message = 'The average trend is Strong Down.')
alertcondition(trendAvg <= -0.2 and trendAvg > -0.8, title = 'Down Alert', message = 'The average trend is Down.')
alertcondition(trendAvg > -0.2 and trendAvg < 0.2, title = 'Neutral Alert', message = 'The average trend is Neutral.')
alertcondition(trendAvg >= 0.2 and trendAvg < 0.8, title = 'Up Alert', message = 'The average trend is Up.')
alertcondition(trendAvg >= 0.8, title = 'Strong Up Alert', message = 'The average trend is Strong Up.')

// Candlestick pattern alert conditions
// if use_candlestick_patterns
    // alertcondition(C_EngulfingBullish, title = "Engulfing - Bullish", message = "Bullish Engulfing pattern detected")
    // alertcondition(C_EngulfingBearish, title = "Engulfing - Bearish", message = "Bearish Engulfing pattern detected")
    // alertcondition(C_HammerBullish, title = "Hammer - Bullish", message = "Bullish Hammer pattern detected")
    // alertcondition(C_ShootingStarBearish, title = "Shooting Star - Bearish", message = "Bearish Shooting Star pattern detected")
    // alertcondition(C_MorningStarBullish, title = "Morning Star - Bullish", message = "Bullish Morning Star pattern detected")
    // alertcondition(C_EveningStarBearish, title = "Evening Star - Bearish", message = "Bearish Evening Star pattern detected")
    // alertcondition(C_Doji, title = "Doji", message = "Doji pattern detected - indicating indecision")
    // alertcondition(C_TweezerBottomBullish, title = "Tweezer Bottom - Bullish", message = "Bullish Tweezer Bottom pattern detected")
    // alertcondition(C_TweezerTopBearish, title = "Tweezer Top - Bearish", message = "Bearish Tweezer Top pattern detected")
